<rules>
  <rule>
    <key>TypesTooBigCritical</key>
    <severity>CRITICAL</severity>
    <name><![CDATA[Types too big - critical]]></name>
    <group>Code Quality</group>
    <scope>Type</scope>
    <code><![CDATA[
warnif count > 0 from t in JustMyCode.Types where
   t.NbLinesOfCode > 500
   // We've commented # IL Instructions, because with LINQ syntax, a few lines of code can compile to hundreds of IL instructions.
   // || t.NbILInstructions > 3000
   orderby t.NbLinesOfCode descending
]]></code>
    <description><![CDATA[Types too big - critical]]></description>
  </rule>
  <rule>
    <key>MethodsTooComplexCritical</key>
    <severity>CRITICAL</severity>
    <name><![CDATA[Methods too complex - critical]]></name>
    <group>Code Quality</group>
    <scope>Method</scope>
    <code><![CDATA[
warnif count > 0 from m in JustMyCode.Methods where
  m.ILCyclomaticComplexity > 40 &&
  m.ILNestingDepth > 5
  orderby m.ILCyclomaticComplexity descending,
          m.ILNestingDepth descending
]]></code>
    <description><![CDATA[Methods too complex - critical]]></description>
  </rule>
  <rule>
    <key>MethodsWithTooManyParametersCritical</key>
    <severity>CRITICAL</severity>
    <name><![CDATA[Methods with too many parameters - critical]]></name>
    <group>Code Quality</group>
    <scope>Method</scope>
    <code><![CDATA[
warnif count > 0 from m in JustMyCode.Methods where
  m.NbParameters > 8
  orderby m.NbParameters descending
]]></code>
    <description><![CDATA[Methods with too many parameters - critical]]></description>
  </rule>
  <rule>
    <key>MethodsTooBig</key>
    <severity>MINOR</severity>
    <name><![CDATA[Methods too big]]></name>
    <group>Code Quality</group>
    <scope>Method</scope>
    <code><![CDATA[
warnif count > 0 from m in JustMyCode.Methods where
   m.NbLinesOfCode > 30
   // We've commented # IL Instructions, because with LINQ syntax, a few lines of code can compile to hundreds of IL instructions.
   // || m.NbILInstructions > 200
   orderby m.NbLinesOfCode descending,
           m.NbILInstructions descending
]]></code>
    <description><![CDATA[Methods too big]]></description>
  </rule>
  <rule>
    <key>MethodsTooComplex</key>
    <severity>MINOR</severity>
    <name><![CDATA[Methods too complex]]></name>
    <group>Code Quality</group>
    <scope>Method</scope>
    <code><![CDATA[
warnif count > 0 from m in JustMyCode.Methods where
  m.CyclomaticComplexity > 20 ||
  m.ILCyclomaticComplexity > 40 ||
  m.ILNestingDepth > 5
  orderby m.CyclomaticComplexity descending,
          m.ILCyclomaticComplexity descending,
          m.ILNestingDepth descending
]]></code>
    <description><![CDATA[Methods too complex]]></description>
  </rule>
  <rule>
    <key>MethodsPotentiallyPoorlyCommented</key>
    <severity>MINOR</severity>
    <name><![CDATA[Methods potentially poorly commented]]></name>
    <group>Code Quality</group>
    <scope>Method</scope>
    <code><![CDATA[
warnif count > 0 from m in JustMyCode.Methods where
  m.PercentageComment < 20 &&
  m.NbLinesOfCode > 20
  orderby m.PercentageComment ascending
]]></code>
    <description><![CDATA[Methods potentially poorly commented]]></description>
  </rule>
  <rule>
    <key>MethodsWithTooManyParameters</key>
    <severity>MINOR</severity>
    <name><![CDATA[Methods with too many parameters]]></name>
    <group>Code Quality</group>
    <scope>Method</scope>
    <code><![CDATA[
warnif count > 0 from m in JustMyCode.Methods where
  m.NbParameters > 5
  orderby m.NbParameters descending
]]></code>
    <description><![CDATA[Methods with too many parameters]]></description>
  </rule>
  <rule>
    <key>MethodsWithTooManyLocalVariables</key>
    <severity>MINOR</severity>
    <name><![CDATA[Methods with too many local variables]]></name>
    <group>Code Quality</group>
    <scope>Method</scope>
    <code><![CDATA[
warnif count > 0 from m in JustMyCode.Methods where
  m.NbVariables > 15
  orderby m.NbVariables descending
]]></code>
    <description><![CDATA[Methods with too many local variables]]></description>
  </rule>
  <rule>
    <key>MethodsWithTooManyOverloads</key>
    <severity>MINOR</severity>
    <name><![CDATA[Methods with too many overloads]]></name>
    <group>Code Quality</group>
    <scope>Method</scope>
    <code><![CDATA[
warnif count > 0 from m in JustMyCode.Methods where
  m.NbOverloads > 6 &&
  !m.IsOperator // Don't report operator overload
  orderby m.NbOverloads descending
]]></code>
    <description><![CDATA[Methods with too many overloads]]></description>
  </rule>
  <rule>
    <key>TypesWithTooManyMethods</key>
    <severity>MINOR</severity>
    <name><![CDATA[Types with too many methods]]></name>
    <group>Code Quality</group>
    <scope>Type</scope>
    <code><![CDATA[
warnif count > 0 from t in JustMyCode.Types
  // Optimization: Fast discard of non-relevant types
  where t.Methods.Count() > 20
  // Don't match these methods
  let methods = t.Methods.Where(
       m => !(m.IsConstructor || m.IsClassConstructor ||
              m.IsGeneratedByCompiler ||
              m.IsPropertyGetter || m.IsPropertySetter ||
              m.IsEventAdder || m.IsEventRemover))
  where methods.Count() > 20
  orderby methods.Count() descending
]]></code>
    <description><![CDATA[Types with too many methods]]></description>
  </rule>
  <rule>
    <key>TypesWithTooManyFields</key>
    <severity>MINOR</severity>
    <name><![CDATA[Types with too many fields]]></name>
    <group>Code Quality</group>
    <scope>Type</scope>
    <code><![CDATA[
warnif count > 0 from t in JustMyCode.Types where
  t.Fields.Count() > 20 &&
  !t.IsEnumeration
  orderby t.Fields.Count() descending
]]></code>
    <description><![CDATA[Types with too many fields]]></description>
  </rule>
  <rule>
    <key>TypesWithPoorCohesion</key>
    <severity>MINOR</severity>
    <name><![CDATA[Types with poor cohesion]]></name>
    <group>Code Quality</group>
    <scope>Type</scope>
    <code><![CDATA[
warnif count > 0 from t in JustMyCode.Types where
  (t.LCOM > 0.8 || t.LCOMHS > 0.95) &&
  t.NbFields > 10 &&
  t.NbMethods >10
  orderby t.LCOM descending, t.LCOMHS descending
]]></code>
    <description><![CDATA[Types with poor cohesion]]></description>
  </rule>
  <rule>
    <key>FromNowAllMethodsAddedOrRefactoredShouldRespectBasicQualityPrinciples</key>
    <severity>MINOR</severity>
    <name><![CDATA[From now, all methods added or refactored should respect basic quality principles]]></name>
    <group>Code Quality Regression</group>
    <scope>Method</scope>
    <code><![CDATA[
warnif count > 0 from m in JustMyCode.Methods where
// *** Only new or modified methods since Baseline for Comparison ***
 (m.WasAdded() || m.CodeWasChanged()) &&
// Low Quality methods// Metrics' definitions
(  m.NbLinesOfCode > 30 ||          // http://www.ndepend.com/Metrics.aspx#NbLinesOfCode
   m.NbILInstructions > 200 ||      // http://www.ndepend.com/Metrics.aspx#NbILInstructions
   m.CyclomaticComplexity > 20 ||   // http://www.ndepend.com/Metrics.aspx#CC
   m.ILCyclomaticComplexity > 50 || // http://www.ndepend.com/Metrics.aspx#ILCC
   m.ILNestingDepth > 4 ||          // http://www.ndepend.com/Metrics.aspx#ILNestingDepth
   m.NbParameters > 5 ||            // http://www.ndepend.com/Metrics.aspx#NbParameters
   m.NbVariables > 8 ||             // http://www.ndepend.com/Metrics.aspx#NbVariables
   m.NbOverloads > 6 )
]]></code>
    <description><![CDATA[From now, all methods added or refactored should respect basic quality principles]]></description>
  </rule>
  <rule>
    <key>FromNowAllTypesAddedOrRefactoredShouldRespectBasicQualityPrinciples</key>
    <severity>MINOR</severity>
    <name><![CDATA[From now, all types added or refactored should respect basic quality principles]]></name>
    <group>Code Quality Regression</group>
    <scope>Type</scope>
    <code><![CDATA[
warnif count > 0 from t in JustMyCode.Types where
// *** Only match new or modified types since Baseline for Comparison ***
(t.WasAdded() || t.CodeWasChanged()) &&
// Eliminate interfaces, enumerations or types only with constant fields
// by making sure we are matching type with code.
t.NbLinesOfCode > 10 &&
// Low Quality types     Metrics' definitions are available here:
//     http://www.ndepend.com/Metrics.aspx#MetricsOnTypes
(  // Types with too many methods
   t.NbMethods > 20 ||
   // Types with too many fields
   t.NbFields > 20 ||
   // Complex Types that use more than 50 other types
   t.NbTypesUsed > 50
)
]]></code>
    <description><![CDATA[From now, all types added or refactored should respect basic quality principles]]></description>
  </rule>
  <rule>
    <key>FromNowAllTypesAddedOrRefactoredShouldBeCoveredByTests</key>
    <severity>MINOR</severity>
    <name><![CDATA[From now, all types added or refactored should be 100% covered by tests]]></name>
    <group>Code Quality Regression</group>
    <scope>Type</scope>
    <code><![CDATA[
warnif count > 0 from t in JustMyCode.Types where
  // Match methods new or modified since Baseline for Comparison...
  (t.WasAdded() || t.CodeWasChanged()) &&
  // ...that are not 100% covered by tests
  t.PercentageCoverage < 100
  let methodsCulprit = t.Methods.Where(m => m.PercentageCoverage < 100)
]]></code>
    <description><![CDATA[From now, all types added or refactored should be 100% covered by tests]]></description>
  </rule>
  <rule>
    <key>AvoidDecreasingCodeCoverageByTestsOfTypes</key>
    <severity>MINOR</severity>
    <name><![CDATA[Avoid decreasing code coverage by tests of types]]></name>
    <group>Code Quality Regression</group>
    <scope>Type</scope>
    <code><![CDATA[
// To visualize changes in code, right-click a matched type and select:
//  - Compare older and newer versions of source file
//  - Compare older and newer versions disassembled with Reflector
warnif count > 0
from t in JustMyCode.Types where
  t.IsPresentInBothBuilds() &&
  t.PercentageCoverage < t.OlderVersion().PercentageCoverage
]]></code>
    <description><![CDATA[Avoid decreasing code coverage by tests of types]]></description>
  </rule>
  <rule>
    <key>TypesThatUsedToBeCoveredButNotAnymore</key>
    <severity>MINOR</severity>
    <name><![CDATA[Types that used to be 100% covered but not anymore]]></name>
    <group>Code Quality Regression</group>
    <scope>Type</scope>
    <code><![CDATA[
warnif count > 0
from t in JustMyCode.Types where
   t.IsPresentInBothBuilds() &&
   t.OlderVersion().PercentageCoverage == 100 &&
   t.PercentageCoverage < 100
let culpritMethods = t.Methods.Where(m => m.PercentageCoverage < 100)
]]></code>
    <description><![CDATA[Types that used to be 100% covered but not anymore]]></description>
  </rule>
  <rule>
    <key>AvoidMakingComplexMethodsEvenMoreComplexsourceCc</key>
    <severity>MINOR</severity>
    <name><![CDATA[Avoid making complex methods even more complex (Source CC)]]></name>
    <group>Code Quality Regression</group>
    <scope>Method</scope>
    <code><![CDATA[
// To visualize changes in code, right-click a matched method and select:
//  - Compare older and newer versions of source file
//  - Compare older and newer versions disassembled with Reflector
warnif count > 0
from m in JustMyCode.Methods where
 !m.IsAbstract &&
  m.IsPresentInBothBuilds() &&
  m.CodeWasChanged()
let oldCC = m.OlderVersion().CyclomaticComplexity
where oldCC > 6 && m.CyclomaticComplexity > oldCC
]]></code>
    <description><![CDATA[Avoid making complex methods even more complex (Source CC)]]></description>
  </rule>
  <rule>
    <key>AvoidMakingComplexMethodsEvenMoreComplexilCc</key>
    <severity>MINOR</severity>
    <name><![CDATA[Avoid making complex methods even more complex (IL CC)]]></name>
    <group>Code Quality Regression</group>
    <scope>Method</scope>
    <code><![CDATA[
// To visualize changes in code, right-click a matched method and select:
//  - Compare older and newer versions of source file
//  - Compare older and newer versions disassembled with Reflector
warnif count > 0
from m in JustMyCode.Methods where
 !m.IsAbstract &&
  m.IsPresentInBothBuilds() &&
  m.CodeWasChanged()
let oldCC = m.OlderVersion().ILCyclomaticComplexity
where oldCC > 10 && m.ILCyclomaticComplexity > oldCC
]]></code>
    <description><![CDATA[Avoid making complex methods even more complex (IL CC)]]></description>
  </rule>
  <rule>
    <key>AvoidMakingLargeMethodsEvenLarger</key>
    <severity>MINOR</severity>
    <name><![CDATA[Avoid making large methods even larger]]></name>
    <group>Code Quality Regression</group>
    <scope>Method</scope>
    <code><![CDATA[
// To visualize changes in code, right-click a matched method and select:
//  - Compare older and newer versions of source file
//  - Compare older and newer versions disassembled with Reflector
warnif count > 0
from m in JustMyCode.Methods where
 !m.IsAbstract &&
  m.IsPresentInBothBuilds() &&
  m.CodeWasChanged() &&
 // Eliminate constructors from match, since they get larger
 // as soons as some fields initialization are added.
 !m.IsConstructor &&
 !m.IsClassConstructor
let oldLoc = m.OlderVersion().NbLinesOfCode
where oldLoc > 15 && m.NbLinesOfCode > oldLoc
]]></code>
    <description><![CDATA[Avoid making large methods even larger]]></description>
  </rule>
  <rule>
    <key>AvoidAddingMethodsToATypeThatAlreadyHadManyMethods</key>
    <severity>MINOR</severity>
    <name><![CDATA[Avoid adding methods to a type that already had many methods]]></name>
    <group>Code Quality Regression</group>
    <scope>Type</scope>
    <code><![CDATA[
// To visualize changes in code, right-click a matched type and select:
//  - Compare older and newer versions of source file
//  - Compare older and newer versions disassembled with Reflector
warnif count > 0
from t in JustMyCode.Types where
  t.IsPresentInBothBuilds() &&
  t.Methods.Count() > t.OlderVersion().Methods.Count() &&
  t.OlderVersion().Methods.Count() > 10
let newMethods = t.Methods.Where(m => m.WasAdded())
let removedMethods = t.OlderVersion().Methods.Where(m => m.WasRemoved())
]]></code>
    <description><![CDATA[Avoid adding methods to a type that already had many methods]]></description>
  </rule>
  <rule>
    <key>AvoidTransformingAnImmutableTypeIntoAMutableOne</key>
    <severity>MINOR</severity>
    <name><![CDATA[Avoid transforming an immutable type into a mutable one]]></name>
    <group>Code Quality Regression</group>
    <scope>Type</scope>
    <code><![CDATA[
// Users of an immutable type often rely on the fact that the type is immutable.
// If an immutable type becomes mutable, there are chances that this will break its users.
warnif count > 0
from t in Application.Types where
   t.IsPresentInBothBuilds() &&
   t.OlderVersion().IsImmutable &&
  !t.IsImmutable &&
  // Don't take account of immutable types transformed into static types (not deemed as immtable)
  !t.IsStatic
let culpritFields = t.Fields.Where(f => f.IsImmutable)
]]></code>
    <description><![CDATA[Avoid transforming an immutable type into a mutable one]]></description>
  </rule>
  <rule>
    <key>AvoidAddingInstanceFieldsToATypeThatAlreadyHadManyInstanceFields</key>
    <severity>MINOR</severity>
    <name><![CDATA[Avoid adding instance fields to a type that already had many instance fields]]></name>
    <group>Code Quality Regression</group>
    <scope>Type</scope>
    <code><![CDATA[
// To visualize changes in code, right-click a matched type and select:
//  - Compare older and newer versions of source file
//  - Compare older and newer versions disassembled with Reflector
warnif count > 0
from t in JustMyCode.Types where
  t.IsPresentInBothBuilds() &&
 !t.IsStatic
let oldNbInstanceFields = t.OlderVersion().InstanceFields
let newNbInstanceFields = t.InstanceFields
where
  newNbInstanceFields.Count() > oldNbInstanceFields .Count() &&
  oldNbInstanceFields.Count() > 6
let newInstanceFields = t.InstanceFields.Where(f => f.WasAdded())
]]></code>
    <description><![CDATA[Avoid adding instance fields to a type that already had many instance fields]]></description>
  </rule>
  <rule>
    <key>ClassShouldntBeTooDeepInInheritanceTree</key>
    <severity>MINOR</severity>
    <name><![CDATA[Class shouldn't be too deep in inheritance tree]]></name>
    <group>Object Oriented Design</group>
    <scope>Type</scope>
    <code><![CDATA[
warnif count > 0 from t in JustMyCode.Types
where t.IsClass
let baseClasses = t.BaseClasses.ExceptThirdParty()
// Warn for classes with 3 or more base classes.
// Notice that we don't count third-party classes
// because this rule concerns your code design,
// not third-party libraries consumed design.
where baseClasses.Count() >= 3
]]></code>
    <description><![CDATA[Class shouldn't be too deep in inheritance tree]]></description>
  </rule>
  <rule>
    <key>ClassWithNoDescendantShouldBeSealedIfPossible</key>
    <severity>MINOR</severity>
    <name><![CDATA[Class with no descendant should be sealed if possible]]></name>
    <group>Object Oriented Design</group>
    <scope>Type</scope>
    <code><![CDATA[
warnif count > 0 from t in JustMyCode.Types where
  t.IsClass &&
  t.NbChildren ==0 &&
 !t.IsSealed &&
 !t.IsStatic
  // && !t.IsPublic <-- You might want to add this condition
  //                    if you are developing a framework
  //                    with classes that are intended to be
  //                    sub-classed by your clients.
  orderby t.NbLinesOfCode descending
]]></code>
    <description><![CDATA[Class with no descendant should be sealed if possible]]></description>
  </rule>
  <rule>
    <key>OverridesOfMethodShouldCallBasemethod</key>
    <severity>MINOR</severity>
    <name><![CDATA[Overrides of Method() should call base.Method()]]></name>
    <group>Object Oriented Design</group>
    <scope>Type</scope>
    <code><![CDATA[
// Overrides of Method() should refine the behavior of base.Method().
// If base.Method() is not called, the base behavior is not refined but it is replaced.
// Violations of this rule are a sign of design flaw,
// especially if the design provides valid reasons
// that advocates that the base behavior must be replaced and not refined.
//
// Discussions on this topic are available here:
//  http://stackoverflow.com/questions/1107022/should-i-call-the-base-class-implementation-when-overriding-a-method-in-c-sharp
//  http://stackoverflow.com/questions/2945147/make-sure-base-method-gets-called-in-c-sharp
warnif count > 0
from t in Types  // Take account of third-party types too
// Bother only classes with descendant
where t.IsClass && t.NbChildren > 0
from mBase in t.InstanceMethods
where  mBase.IsVirtual &&
      !mBase.IsThirdParty &&
      !mBase.IsAbstract &&
      !mBase.IsExplicitInterfaceImpl
from mOverride in mBase.OverridesDirectDerived
where !mOverride.IsUsing(mBase)
]]></code>
    <description><![CDATA[Overrides of Method() should call base.Method()]]></description>
  </rule>
  <rule>
    <key>DoNotHideBaseClassMethods</key>
    <severity>CRITICAL</severity>
    <name><![CDATA[Do not hide base class methods]]></name>
    <group>Object Oriented Design</group>
    <scope>Type</scope>
    <code><![CDATA[
// To fix a violation of this rule, remove or rename the method, or change the parameter signature
// so that the method does not hide the base method.
// More on hiding vs. virtual usefulness here:
//  http://www.artima.com/intv/nonvirtual.html
//  http://blogs.msdn.com/b/ericlippert/archive/2008/05/21/method-hiding-apologia.aspx
warnif count > 0
// Define a lookup table indexing methods by their name including parameters signature.
let lookup = Methods.Where(m => !m.IsConstructor && !m.IsStatic && !m.IsGeneratedByCompiler)
                    .ToLookup(m1 => m1.Name)
from t in Application.Types
where !t.IsStatic && t.IsClass &&
   // Discard classes deriving directly from System.Object
   t.DepthOfInheritance > 1
where t.BaseClasses.Any()
// For each methods not overriding any methods (new slot),
// let's check if it hides by name some methods defined in base classe.
from m in t.InstanceMethods
where m.IsNewSlot && !m.IsExplicitInterfaceImpl && !m.IsGeneratedByCompiler
// Notice how lookup is used to quickly retrieve methods with same name as m.
// This makes the query 10 times faster than iterating each base methods to check their name.
let baseMethodsHidden = lookup[m.Name].Where(m1 => m1 != m && t.DeriveFrom(m1.ParentType))
where baseMethodsHidden.Count() > 0
]]></code>
    <description><![CDATA[Do not hide base class methods]]></description>
  </rule>
  <rule>
    <key>AStatelessClassOrStructureMightBeTurnedIntoAStaticType</key>
    <severity>MINOR</severity>
    <name><![CDATA[A stateless class or structure might be turned into a static type]]></name>
    <group>Object Oriented Design</group>
    <scope>Type</scope>
    <code><![CDATA[
// This rule indicates stateless types that might
// eventually be turned into static classes.
warnif count > 0 from t in JustMyCode.Types where
  !t.IsStatic &&
  !t.IsGeneric &&
   t.InstanceFields.Count() == 0 &&
   // Don't match:
   // --> types that implement some interfaces.
   t.NbInterfacesImplemented == 0 &&
   // --> or classes that have sub-classes children.
   t.NbChildren == 0 &&
   // --> or classes that have a base class
   ((t.IsClass && t.DepthOfDeriveFrom("System.Object".AllowNoMatch()) == 1) ||
     t.IsStructure)
]]></code>
    <description><![CDATA[A stateless class or structure might be turned into a static type]]></description>
  </rule>
  <rule>
    <key>NonstaticClassesShouldBeInstantiatedOrTurnedToStatic</key>
    <severity>MINOR</severity>
    <name><![CDATA[Non-static classes should be instantiated or turned to static]]></name>
    <group>Object Oriented Design</group>
    <scope>Type</scope>
    <code><![CDATA[
// Notice that classes only instantiated through reflection, like plug-in root classes
// are matched by this rules.
warnif count > 0
from t in JustMyCode.Types
where  t.IsClass &&
    //!t.IsPublic &&   // if you are developing a framework,
                       // you might not want to match public classes
      !t.IsStatic &&
      !t.IsAttributeClass && // Attributes class are never seen as instantiated
      !t.DeriveFrom("System.MarshalByRefObject".AllowNoMatch()) // Types instantiated through remoting infrastructure
// find the first constructor of t called
let ctorCalled = t.Constructors.FirstOrDefault(ctor => ctor.NbMethodsCallingMe > 0)
// match t if none of its constructors is called.
where ctorCalled == null
]]></code>
    <description><![CDATA[Non-static classes should be instantiated or turned to static]]></description>
  </rule>
  <rule>
    <key>MethodsShouldBeDeclaredStaticIfPossible</key>
    <severity>MINOR</severity>
    <name><![CDATA[Methods should be declared static if possible]]></name>
    <group>Object Oriented Design</group>
    <scope>Type</scope>
    <code><![CDATA[
warnif count > 0
// When an instance method can be safely declared as static you should declare it as static.
// Since it doesn't use any instance data and method of its type and base-types,
// you should consider if such a method could be moved to a static utility class
// or if it is strongly related enough to its current declaring type to stay in it.
//
// Turning an instance method into a static method is a micro performance optimization
// since a static method is a bit cheaper to invoke than an instance method.
from t in JustMyCode.Types.Where(t =>
   !t.IsStatic && !t.IsInterface &&
   !t.IsEnumeration && !t.IsDelegate &&
   !t.IsGeneratedByCompiler)
let methodsThatCanBeMadeStatic =
   from m in t.InstanceMethods
   // An instance method can be turned to static if it is not virtual,
   // not using the this reference and also, not using
   // any of its class or base classes instance fields or instance methods.
   where !m.IsAbstract && !m.IsVirtual &&
         !m.AccessThis && !m.IsExplicitInterfaceImpl &&
          // Optimization: Using FirstOrDefault() avoid to check all members,
          //               as soon as one member is found
          //               we know the method m cannot be made static.
          m.MembersUsed.FirstOrDefault(
              mUsed => !mUsed.IsStatic &&
                       (mUsed.ParentType == t ||
                        t.DeriveFrom(mUsed.ParentType))
          ) == null
   select m
from m in methodsThatCanBeMadeStatic
let staticFieldsUsed = m.ParentType.StaticFields.UsedBy(m).Where(f => !f.IsGeneratedByCompiler)
]]></code>
    <description><![CDATA[Methods should be declared static if possible]]></description>
  </rule>
  <rule>
    <key>ConstructorShouldNotCallAVirtualMethods</key>
    <severity>MINOR</severity>
    <name><![CDATA[Constructor should not call a virtual methods]]></name>
    <group>Object Oriented Design</group>
    <scope>Type</scope>
    <code><![CDATA[
// Returns constructor of a non-sealed type calling virtual methods.
// In such a situation, if a derived class overrides the method,
// then the override method will be called before the derived constructor.
// This makes the class fragile to derive from.
//
// Violations reported can be solved by re-designing object initialisation
// or by marking the parent class as sealed, if possible.
warnif count > 0
from t in Application.Types where
   t.IsClass &&
  !t.IsGeneratedByCompiler &&
  !t.IsSealed
from ctor in t.Constructors
let virtualMethodsCalled = from mCalled in ctor.MethodsCalled
                           where mCalled.IsVirtual &&
                                (mCalled.ParentType == t ||
                                 t.DeriveFrom(mCalled.ParentType))
                           select mCalled
where virtualMethodsCalled.Count() > 0
]]></code>
    <description><![CDATA[Constructor should not call a virtual methods]]></description>
  </rule>
  <rule>
    <key>AvoidTheSingletonPattern</key>
    <severity>MINOR</severity>
    <name><![CDATA[Avoid the Singleton pattern]]></name>
    <group>Object Oriented Design</group>
    <scope>Type</scope>
    <code><![CDATA[
warnif count > 0
from t in Application.Types
where !t.IsStatic && !t.IsAbstract && (t.IsClass || t.IsStructure)
// All ctors of a singleton are private
where t.Constructors.Where(ctor => !ctor.IsPrivate).Count() == 0
// A singleton contains one static field of its parent type, to reference the unique instance
let staticFieldInstances = t.StaticFields.WithFieldType(t)
where staticFieldInstances.Count() == 1
]]></code>
    <description><![CDATA[Avoid the Singleton pattern]]></description>
  </rule>
  <rule>
    <key>AvoidEmptyInterfaces</key>
    <severity>MINOR</severity>
    <name><![CDATA[Avoid empty interfaces]]></name>
    <group>Object Oriented Design</group>
    <scope>Type</scope>
    <code><![CDATA[
warnif count > 0 from t in JustMyCode.Types where
  t.IsInterface &&
  t.NbMethods == 0
]]></code>
    <description><![CDATA[Avoid empty interfaces]]></description>
  </rule>
  <rule>
    <key>AvoidCustomDelegates</key>
    <severity>MINOR</severity>
    <name><![CDATA[Avoid custom delegates]]></name>
    <group>Design</group>
    <scope>Type</scope>
    <code><![CDATA[
// Prefer using one of the standard generic delegate type in
// Predicate<T> Func<T0,T1,..,TResult> Action<T0,T1,..>
// instead of creating your own delegate type.
// Not only the code using these custom delegates will become clearer,
// but you'll be relieved from the maintenance of these delegate types.
//
// Notice that delegate that are consumed by DllImport extern methods
// must not be converted, else this could provoke marshalling issues.
warnif count > 0
from t in Application.Types where t.IsDelegate
let invokeMethod = (from m in t.Methods where m.SimpleName == "Invoke" select m).Single()
let signature1 = invokeMethod.Name.Substring(invokeMethod.SimpleName.Length, invokeMethod.Name.Length - invokeMethod.SimpleName.Length)
// 'ref' and 'out' parameters canot be supported
where !signature1.Contains("&")
let signature2 = signature1.Replace("(","<").Replace(")",">")
let signature3 = signature2 == "<>" ? "" : signature2
let resultTypeName = invokeMethod.ReturnType == null ? "????" :
                     invokeMethod.ReturnType.FullName == "System.Void" ? "" :
                     invokeMethod.ReturnType.Name
let replaceWith = resultTypeName == "Boolean" ?
      "Predicate" + signature3 : resultTypeName == "" ?
      "Action" + signature3  :
      "Func" + signature3.Replace(">", "," + resultTypeName + ">")
]]></code>
    <description><![CDATA[Avoid custom delegates]]></description>
  </rule>
  <rule>
    <key>TypesWithDisposableInstanceFieldsMustBeDisposable</key>
    <severity>MINOR</severity>
    <name><![CDATA[Types with disposable instance fields must be disposable]]></name>
    <group>Design</group>
    <scope>Type</scope>
    <code><![CDATA[
warnif count > 0
// Several IDisposable type can be found if several .NET Fx are referenced.
let iDisposables = ThirdParty.Types.WithFullName("System.IDisposable")
where iDisposables.Any() // in case the code base doesn't use at all System.IDisposable
from t in Application.Types.Except(Application.Types.ThatImplementAny(iDisposables))
where !t.IsGeneratedByCompiler
let instanceFieldsDisposable =
    t.InstanceFields.Where(f => f.FieldType != null &&
                                f.FieldType.InterfacesImplemented.Intersect(iDisposables).Any())
where instanceFieldsDisposable.Any()
]]></code>
    <description><![CDATA[Types with disposable instance fields must be disposable]]></description>
  </rule>
  <rule>
    <key>ClassesThatAreCandidateToBeTurnedIntoStructures</key>
    <severity>MINOR</severity>
    <name><![CDATA[Classes that are candidate to be turned into structures]]></name>
    <group>Design</group>
    <scope>Type</scope>
    <code><![CDATA[
//
// CAUTION: Before applying this rule, make sure to understand
//          the implication of transforming a class into a structure.
//          http://msdn.microsoft.com/en-us/library/aa664471(v=vs.71).aspx
//
// Int32, Double or Boolean are structures and not classes.
// Structure are particularly suited to implement lightweight values.
// Hence a class is candidate to be turned into a structure
// when its instances are lightweight values.
//
warnif count > 0 from t in JustMyCode.Types where
  t.IsClass &&
 !t.IsGeneratedByCompiler &&
 !t.IsStatic &&
  t.SizeOfInst > 0 &&
  t.SizeOfInst <= 16 &&   // Structure instance must not be too big,
                          // else it degrades performance.
  t.NbChildren == 0 &&    // Must not have children
  // Must not implement interfaces to avoid boxing mismatch
  // when structures implements interfaces.
  t.InterfacesImplemented.Count() == 0 &&
  // Must have no base class
  t.DepthOfDeriveFrom("System.Object".AllowNoMatch()) == 1
]]></code>
    <description><![CDATA[Classes that are candidate to be turned into structures]]></description>
  </rule>
  <rule>
    <key>NestedTypesShouldNotBeVisible</key>
    <severity>MINOR</severity>
    <name><![CDATA[Nested types should not be visible]]></name>
    <group>Design</group>
    <scope>Type</scope>
    <code><![CDATA[
warnif count > 0 from t in JustMyCode.Types where
  t.IsNested &&
 !t.IsGeneratedByCompiler &&
 !t.IsPrivate
]]></code>
    <description><![CDATA[Nested types should not be visible]]></description>
  </rule>
  <rule>
    <key>EmptyStaticConstructorCanBeDiscarded</key>
    <severity>MINOR</severity>
    <name><![CDATA[Empty static constructor can be discarded]]></name>
    <group>Design</group>
    <scope>Method</scope>
    <code><![CDATA[
warnif count > 0 from m in Application.Methods where
  m.IsClassConstructor &&
  m.NbLinesOfCode == 0
]]></code>
    <description><![CDATA[Empty static constructor can be discarded]]></description>
  </rule>
  <rule>
    <key>InstancesSizeShouldntBeTooBig</key>
    <severity>MINOR</severity>
    <name><![CDATA[Instances size shouldn't be too big]]></name>
    <group>Design</group>
    <scope>Type</scope>
    <code><![CDATA[
warnif count > 0 from t in JustMyCode.Types where
  t.SizeOfInst > 64
  orderby t.SizeOfInst descending
]]></code>
    <description><![CDATA[Instances size shouldn't be too big]]></description>
  </rule>
  <rule>
    <key>BoxingunboxingShouldBeAvoided</key>
    <severity>MINOR</severity>
    <name><![CDATA[Boxing/unboxing should be avoided]]></name>
    <group>Design</group>
    <scope>Method</scope>
    <code><![CDATA[
warnif percentage > 5 from m in Application.Methods where
  m.IsUsingBoxing ||
  m.IsUsingUnboxing
]]></code>
    <description><![CDATA[Boxing/unboxing should be avoided]]></description>
  </rule>
  <rule>
    <key>AttributeClassesShouldBeSealed</key>
    <severity>MINOR</severity>
    <name><![CDATA[Attribute classes should be sealed]]></name>
    <group>Design</group>
    <scope>Type</scope>
    <code><![CDATA[
warnif count > 0 from t in Application.Types where
  t.IsAttributeClass &&
 !t.IsSealed &&
 !t.IsAbstract &&
  t.IsPublic
]]></code>
    <description><![CDATA[Attribute classes should be sealed]]></description>
  </rule>
  <rule>
    <key>DontUseObsoleteTypesMethodsOrFields</key>
    <severity>MINOR</severity>
    <name><![CDATA[Don't use obsolete types, methods or fields]]></name>
    <group>Design</group>
    <scope>Method</scope>
    <code><![CDATA[
warnif count > 0
let obsoleteTypes = Types.Where(t => t.IsObsolete)
let obsoleteMethods = Methods.Where(m => m.IsObsolete).ToHashSet()
let obsoleteFields = Fields.Where(f => f.IsObsolete)
from m in JustMyCode.Methods.UsingAny(obsoleteTypes).Union(
          JustMyCode.Methods.UsingAny(obsoleteMethods)).Union(
          JustMyCode.Methods.UsingAny(obsoleteFields))
let obsoleteTypesUsed = obsoleteTypes.UsedBy(m)
// Optimization: MethodsCalled + Intersect() is faster than using obsoleteMethods.UsedBy()
let obsoleteMethodsUsed = m.MethodsCalled.Intersect(obsoleteMethods)
let obsoleteFieldsUsed = obsoleteFields.UsedBy(m)
]]></code>
    <description><![CDATA[Don't use obsolete types, methods or fields]]></description>
  </rule>
  <rule>
    <key>DontForgetToImplementMethodsThatThrowNotimplementedexception</key>
    <severity>MINOR</severity>
    <name><![CDATA[Don't forget to implement methods that throw NotImplementedException]]></name>
    <group>Design</group>
    <scope>Method</scope>
    <code><![CDATA[
warnif count > 0
from m in Application.Methods
where m.CreateA("System.NotImplementedException".AllowNoMatch())
]]></code>
    <description><![CDATA[Don't forget to implement methods that throw NotImplementedException]]></description>
  </rule>
  <rule>
    <key>EqualsShouldBeOverriddenByTypesImplementingTheOperator</key>
    <severity>MINOR</severity>
    <name><![CDATA[Equals() should be overridden by types implementing the '==' operator]]></name>
    <group>Design</group>
    <scope>Method</scope>
    <code><![CDATA[
warnif count > 0
from m in Application.Methods where
  m.IsOperator &&
  m.SimpleName == "op_Equality"
let equalsMethod = m.ParentType.InstanceMethods.Where(m0 => m0.Name == "Equals(Object)").SingleOrDefault()
where equalsMethod == null
]]></code>
    <description><![CDATA[Equals() should be overridden by types implementing the '==' operator]]></description>
  </rule>
  <rule>
    <key>BrokenSerializableTypes</key>
    <severity>CRITICAL</severity>
    <name><![CDATA[Broken serializable types]]></name>
    <group>API Breaking Changes</group>
    <scope>Type</scope>
    <code><![CDATA[
// Find breaking changes in types marked with SerializableAttribute.
warnif count > 0
from t in Application.Types where
  // Collect types tagged with SerializableAttribute
  t.HasAttribute("System.SerializableAttribute".AllowNoMatch())  &&
 !t.IsDelegate &&
  t.IsPresentInBothBuilds() &&
  t.HasAttribute(t)
  // Find newer and older versions of NonSerializedAttribute
  let newNonSerializedAttribute = ThirdParty.Types.WithFullName("System.NonSerializedAttribute").SingleOrDefault()
  let oldNonSerializedAttribute = newNonSerializedAttribute == null ? null : newNonSerializedAttribute.OlderVersion()
  // Find added or removed fields not marked with NonSerializedAttribute
  let addedInstanceField = from f in t.InstanceFields where
                             f.WasAdded() &&
                             (newNonSerializedAttribute == null || !f.HasAttribute(newNonSerializedAttribute))
                           select f
  let removedInstanceField = from f in t.OlderVersion().InstanceFields where
                             f.WasRemoved() &&
                             (oldNonSerializedAttribute == null || !f.HasAttribute(oldNonSerializedAttribute))
                           select f
  where addedInstanceField.Count() > 0 || removedInstanceField.Count() > 0
]]></code>
    <description><![CDATA[Broken serializable types]]></description>
  </rule>
  <rule>
    <key>AvoidTransformingImmutableTypesIntoMutableTypes</key>
    <severity>CRITICAL</severity>
    <name><![CDATA[Avoid transforming immutable types into mutable types]]></name>
    <group>API Breaking Changes</group>
    <scope>Type</scope>
    <code><![CDATA[
// Immutability is a strong property on a type.
// Breaking immutability can result in serious problem for an algorithm consummer
// that has been written taking account of the type immutability.
// To visualize changes in code, right-click a matched type and select:
//  - Compare older and newer versions of source file
//  - Compare older and newer versions disassembled with Reflector
warnif count > 0
from t in Application.Types where
  t.IsPresentInBothBuilds() &&
 !t.IsStatic &&
 !t.IsImmutable &&
  t.OlderVersion().IsImmutable
let mutableFields = from f in t.InstanceFields where !f.IsImmutable select f
]]></code>
    <description><![CDATA[Avoid transforming immutable types into mutable types]]></description>
  </rule>
  <rule>
    <key>AvoidChangingEnumerationsFlagsStatus</key>
    <severity>CRITICAL</severity>
    <name><![CDATA[Avoid changing enumerations Flags status]]></name>
    <group>API Breaking Changes</group>
    <scope>Type</scope>
    <code><![CDATA[
// Being tagged with the Flags attribute is a strong property for an enumeration.
// Changing the Flags status of an enumeration has significant impact for its client.
warnif count > 0
let oldFlags = codeBase.OlderVersion().ThirdParty.Types.WithFullName("System.FlagsAttribute").SingleOrDefault()
let newFlags = ThirdParty.Types.WithFullName("System.FlagsAttribute").SingleOrDefault()
where oldFlags != null && newFlags != null
from t in Application.Types where
  t.IsEnumeration &&
  t.IsPresentInBothBuilds()
let isFlags = t.HasAttribute(newFlags)
let wasFlags = t.OlderVersion().HasAttribute(oldFlags)
where isFlags != wasFlags
]]></code>
    <description><![CDATA[Avoid changing enumerations Flags status]]></description>
  </rule>
  <rule>
    <key>ApiNewPubliclyVisibleTypes</key>
    <severity>MINOR</severity>
    <name><![CDATA[API: New publicly visible types]]></name>
    <group>API Breaking Changes</group>
    <scope>Type</scope>
    <code><![CDATA[
// List types that are new in the public surface of your assemblies
from t in Application.Types
where t.IsPubliclyVisible &&
     // The type has been removed and its parent assembly hasn't been removed ...
     ( (t.WasAdded() && !t.ParentAssembly.WasAdded()) ||
     // ... or the type existed but was not publicly visible
       !t.WasAdded() && !t.OlderVersion().IsPubliclyVisible)
]]></code>
    <description><![CDATA[API: New publicly visible types]]></description>
  </rule>
  <rule>
    <key>ApiNewPubliclyVisibleMethods</key>
    <severity>MINOR</severity>
    <name><![CDATA[API: New publicly visible methods]]></name>
    <group>API Breaking Changes</group>
    <scope>Method</scope>
    <code><![CDATA[
// List methods that are new in the public surface of your assemblies
from m in Application.Methods
where m.IsPubliclyVisible &&
     // The method has been removed and its parent assembly hasn'm been removed ...
     ( (m.WasAdded() && !m.ParentType.WasAdded()) ||
     // ... or the t existed but was not publicly visible
       !m.WasAdded() && !m.OlderVersion().IsPubliclyVisible)
]]></code>
    <description><![CDATA[API: New publicly visible methods]]></description>
  </rule>
  <rule>
    <key>NewTypes</key>
    <severity>MINOR</severity>
    <name><![CDATA[New types]]></name>
    <group>Code Diff Summary</group>
    <scope>Type</scope>
    <code><![CDATA[
from t in Application.Types where
 !t.ParentNamespace.WasAdded() &&
  t.WasAdded()
]]></code>
    <description><![CDATA[New types]]></description>
  </rule>
  <rule>
    <key>TypesWhereCodeWasChanged</key>
    <severity>MINOR</severity>
    <name><![CDATA[Types where code was changed]]></name>
    <group>Code Diff Summary</group>
    <scope>Type</scope>
    <code><![CDATA[
// To visualize changes in code, right-click a matched type and select:
//  - Compare older and newer versions of source file
//  - Compare older and newer versions disassembled with Reflector
from t in Application.Types where t.CodeWasChanged()
//select new { t, t.NbLinesOfCode }
select new { t, t.NbLinesOfCode,
             oldNbLinesOfCode = t.OlderVersion().NbLinesOfCode ,
             delta = (int?) t.NbLinesOfCode - t.OlderVersion().NbLinesOfCode }
/*from t in Application.Types where t.CodeWasChanged() && t.IsPresentInBothBuild
]]></code>
    <description><![CDATA[Types where code was changed]]></description>
  </rule>
  <rule>
    <key>TypesDirectlyUsingOneOrSeveralTypesChanged</key>
    <severity>MINOR</severity>
    <name><![CDATA[Types directly using one or several types changed]]></name>
    <group>Code Diff Summary</group>
    <scope>Type</scope>
    <code><![CDATA[
let typesChanged = Application.Types.Where(t => t.CodeWasChanged()).ToHashSet()
from t in JustMyCode.Types.UsingAny(typesChanged) where
  !t.CodeWasChanged() &&
  !t.WasAdded()
let typesChangedUsed = t.TypesUsed.Intersect(typesChanged)
]]></code>
    <description><![CDATA[Types directly using one or several types changed]]></description>
  </rule>
  <rule>
    <key>NewMethods</key>
    <severity>MINOR</severity>
    <name><![CDATA[New methods]]></name>
    <group>Code Diff Summary</group>
    <scope>Method</scope>
    <code><![CDATA[
from m in Application.Methods where
 !m.ParentType.WasAdded() &&
  m.WasAdded()
]]></code>
    <description><![CDATA[New methods]]></description>
  </rule>
  <rule>
    <key>MethodsWhereCodeWasChanged</key>
    <severity>MINOR</severity>
    <name><![CDATA[Methods where code was changed]]></name>
    <group>Code Diff Summary</group>
    <scope>Method</scope>
    <code><![CDATA[
// To visualize changes in code, right-click a matched method and select:
//  - Compare older and newer versions of source file
//  - Compare older and newer versions disassembled with Reflector
from m in Application.Methods where m.CodeWasChanged()
]]></code>
    <description><![CDATA[Methods where code was changed]]></description>
  </rule>
  <rule>
    <key>MethodsDirectlyCallingOneOrSeveralMethodsChanged</key>
    <severity>MINOR</severity>
    <name><![CDATA[Methods directly calling one or several methods changed]]></name>
    <group>Code Diff Summary</group>
    <scope>Method</scope>
    <code><![CDATA[
let methodsChanged = Application.Methods.Where(m => m.CodeWasChanged()).ToHashSet()
from m in JustMyCode.Methods.UsingAny(methodsChanged ) where
  !m.CodeWasChanged() &&
  !m.WasAdded()
let methodsChangedCalled = m.MethodsCalled.Intersect(methodsChanged)
]]></code>
    <description><![CDATA[Methods directly calling one or several methods changed]]></description>
  </rule>
  <rule>
    <key>ThirdPartyTypesThatWereNotUsedAndThatAreNowUsed</key>
    <severity>MINOR</severity>
    <name><![CDATA[Third party types that were not used and that are now used]]></name>
    <group>Code Diff Summary</group>
    <scope>Type</scope>
    <code><![CDATA[
from t in ThirdParty.Types where t.IsUsedRecently()
]]></code>
    <description><![CDATA[Third party types that were not used and that are now used]]></description>
  </rule>
  <rule>
    <key>ThirdPartyMethodsThatWereNotUsedAndThatAreNowUsed</key>
    <severity>MINOR</severity>
    <name><![CDATA[Third party methods that were not used and that are now used]]></name>
    <group>Code Diff Summary</group>
    <scope>Method</scope>
    <code><![CDATA[
from m in ThirdParty.Methods where
  m.IsUsedRecently() &&
 !m.ParentType.IsUsedRecently()
]]></code>
    <description><![CDATA[Third party methods that were not used and that are now used]]></description>
  </rule>
  <rule>
    <key>CrapMethodCodeMetric</key>
    <severity>MINOR</severity>
    <name><![CDATA[C.R.A.P method code metric]]></name>
    <group>Test and Code Coverage</group>
    <scope>Method</scope>
    <code><![CDATA[
// Change Risk Analyzer and Predictor (i.e. CRAP) code metric
// This code metric helps in pinpointing overly complex and untested code.
// Reference: http://www.artima.com/weblogs/viewpost.jsp?thread=215899
// Formula:   CRAP(m) = comp(m)^2 * (1 â€“ cov(m)/100)^3 + comp(m)
warnif count > 0
from m in JustMyCode.Methods
// Don't match too short methods
where m.NbLinesOfCode > 10
let CC = m.CyclomaticComplexity
let uncov = (100 - m.PercentageCoverage) / 100f
let CRAP = (CC * CC * uncov * uncov * uncov) + CC
where CRAP != null && CRAP > 30
orderby CRAP descending, m.NbLinesOfCode descending
]]></code>
    <description><![CDATA[C.R.A.P method code metric]]></description>
  </rule>
  <rule>
    <key>ComplexMethodsPartiallyCoveredByTestsShouldBeCovered</key>
    <severity>MINOR</severity>
    <name><![CDATA[Complex methods partially covered by tests should be 100% covered]]></name>
    <group>Test and Code Coverage</group>
    <scope>Method</scope>
    <code><![CDATA[
warnif count > 0 from m in JustMyCode.Methods
 where
     // These metrics' definitions are available here:
     // http://www.ndepend.com/Metrics.aspx#MetricsOnMethods
     (  m.NbLinesOfCode > 30 ||
        m.ILCyclomaticComplexity > 50 ||
        m.ILNestingDepth > 4 ||
        m.NbVariables > 8) &&
     // Take care only of complex methods
     // already partially covered, but not completely covered.
     m.PercentageCoverage > 0 &&
     m.PercentageCoverage < 100
  orderby m.NbLinesOfCodeNotCovered ascending,
          m.NbLinesOfCode descending
]]></code>
    <description><![CDATA[Complex methods partially covered by tests should be 100% covered]]></description>
  </rule>
  <rule>
    <key>MethodChangedPoorlyCovered</key>
    <severity>MINOR</severity>
    <name><![CDATA[Method changed poorly covered]]></name>
    <group>Test and Code Coverage</group>
    <scope>Method</scope>
    <code><![CDATA[
from m in Application.Methods where
  m.PercentageCoverage < 30 &&
  m.CodeWasChanged()
  orderby m.NbLinesOfCode descending,
           m.NbLinesOfCodeNotCovered ,
           m.PercentageCoverage
]]></code>
    <description><![CDATA[Method changed poorly covered]]></description>
  </rule>
  <rule>
    <key>MethodAddedPoorlyCovered</key>
    <severity>MINOR</severity>
    <name><![CDATA[Method added poorly covered]]></name>
    <group>Test and Code Coverage</group>
    <scope>Method</scope>
    <code><![CDATA[
from m in Application.Methods where
  m.NbLinesOfCode > 0 &&
  m.PercentageCoverage < 30 &&
  m.WasAdded()
  orderby m.NbLinesOfCode descending,
           m.NbLinesOfCodeNotCovered ,
           m.PercentageCoverage
]]></code>
    <description><![CDATA[Method added poorly covered]]></description>
  </rule>
  <rule>
    <key>TypesToCovered</key>
    <severity>MINOR</severity>
    <name><![CDATA[Types 95% to 99% covered]]></name>
    <group>Test and Code Coverage</group>
    <scope>Type</scope>
    <code><![CDATA[
from t in Application.Types where
  t.PercentageCoverage >= 95 &&
  t.PercentageCoverage <= 99 &&
 !t.IsGeneratedByCompiler
  let methodsCulprit = t.Methods.Where(m => m.PercentageCoverage < 100)
  orderby t.NbLinesOfCode descending ,
           t.NbLinesOfCodeNotCovered ,
           t.PercentageCoverage
]]></code>
    <description><![CDATA[Types 95% to 99% covered]]></description>
  </rule>
  <rule>
    <key>TypesTaggedWithFullcoveredattributeShouldBeCovered</key>
    <severity>MINOR</severity>
    <name><![CDATA[Types tagged with FullCoveredAttribute should be 100% covered]]></name>
    <group>Test and Code Coverage</group>
    <scope>Type</scope>
    <code><![CDATA[
warnif count > 0
from t in Application.Types where
  t.HasAttribute ("NDepend.Attributes.FullCoveredAttribute".AllowNoMatch()) &&
  t.PercentageCoverage < 100
let notFullCoveredMethods = t.Methods.Where(
                               m =>  m.NbLinesOfCode> 0 &&
                                     m.PercentageCoverage < 100 &&
                                    !m.HasAttribute("NDepend.Attributes.UncoverableByTestAttribute".AllowNoMatch()))
orderby t.NbLinesOfCodeNotCovered descending
]]></code>
    <description><![CDATA[Types tagged with FullCoveredAttribute should be 100% covered]]></description>
  </rule>
  <rule>
    <key>TypesCoveredShouldBeTaggedWithFullcoveredattribute</key>
    <severity>MINOR</severity>
    <name><![CDATA[Types 100% covered should be tagged with FullCoveredAttribute]]></name>
    <group>Test and Code Coverage</group>
    <scope>Type</scope>
    <code><![CDATA[
warnif count > 0 from t in JustMyCode.Types where
 !t.HasAttribute ("NDepend.Attributes.FullCoveredAttribute".AllowNoMatch()) &&
  t.PercentageCoverage == 100 &&
 !t.IsGeneratedByCompiler
]]></code>
    <description><![CDATA[Types 100% covered should be tagged with FullCoveredAttribute]]></description>
  </rule>
  <rule>
    <key>TypesNotCoveredAtAll</key>
    <severity>MINOR</severity>
    <name><![CDATA[Types not covered at all]]></name>
    <group>Test and Code Coverage</group>
    <scope>Type</scope>
    <code><![CDATA[
from t in Application.Types where
  t.PercentageCoverage == 0
  orderby t.NbLinesOfCode descending
]]></code>
    <description><![CDATA[Types not covered at all]]></description>
  </rule>
  <rule>
    <key>MethodsDirectlyCalledByTestMethods</key>
    <severity>MINOR</severity>
    <name><![CDATA[Methods directly called by test Methods]]></name>
    <group>Test and Code Coverage</group>
    <scope>Method</scope>
    <code><![CDATA[
// Lists all methods directly called by tests methods.
// Overrides of virtual and absract methods, called through polymorphism, are not listed.
// Methods solely invoked through a delegate are not listed.
// Methods solely invoked through reflection are not listed.
// We advise to not include test assemblies in code analyzed by NDepend.
// But if you wish the current query to run properly,
// you'll need to consider test assemblies in your list of application assemblies analyzed by NDepend..
let testAttr = ThirdParty.Types.WithNameIn("TestAttribute", "TestCaseAttribute")
let testMethods = Methods.TaggedWithAnyAttributes(testAttr).ToHashSet()
// --- Uncomment this line if your test methods are in dedicated test assemblies ---
//let testAssemblies = testMethods.ParentAssemblies().ToHashSet()
from m in Application.Methods.UsedByAny(testMethods)
// --- Uncomment this line if your test methods are in dedicated test assemblies ---
//where !testAssemblies.Contains(m.ParentAssembly)
]]></code>
    <description><![CDATA[Methods directly called by test Methods]]></description>
  </rule>
  <rule>
    <key>MethodsDirectlyAndIndirectlyCalledByTestMethods</key>
    <severity>MINOR</severity>
    <name><![CDATA[Methods directly and indirectly called by test Methods]]></name>
    <group>Test and Code Coverage</group>
    <scope>Type</scope>
    <code><![CDATA[
// Lists all methods called directly or indirectly by tests methods.
// Overrides of virtual and absract methods, called through polymorphism, are not listed.
// Methods solely invoked through a delegate are not listed.
// Methods solely invoked through reflection are not listed.
// We advise to not include test assemblies in code analyzed by NDepend.
// But if you wish the current query to run properly,
// you'll need to consider test assemblies in your list of application assemblies analyzed by NDepend.
let testAttr = from t in ThirdParty.Types.WithNameIn("TestAttribute", "TestCaseAttribute") select t
let testMethods = Methods.TaggedWithAnyAttributes(testAttr)
// --- Uncomment this line if your test methods are in dedicated test assemblies ---
// let testAssemblies = testMethods.ParentAssemblies().ToHashSet()
let depthOfCalledByTest = Application.Methods.DepthOfIsUsedByAny(testMethods)
from pair in depthOfCalledByTest
where pair.Value > 0
orderby pair.Value ascending
// --- Uncomment this line if your test methods are in dedicated test assemblies ---
//&& !testAssemblies.Contains(pair.CodeElement.ParentAssembly)
]]></code>
    <description><![CDATA[Methods directly and indirectly called by test Methods]]></description>
  </rule>
  <rule>
    <key>PotentiallyDeadTypes</key>
    <severity>CRITICAL</severity>
    <name><![CDATA[Potentially dead Types]]></name>
    <group>Dead Code</group>
    <scope>Type</scope>
    <code><![CDATA[
warnif count > 0
// Filter procedure for types that should'nt be considered as dead
let canTypeBeConsideredAsDeadProc = new Func<IType, bool>(
   t => !t.IsPublic && //   Public types might be used by client applications of your assemblies.
         t.Name != "Program" &&
        !t.IsGeneratedByCompiler &&
         // If you don't want to link NDepend.API.dll, you can use your own IsNotDeadCodeAttribute and adapt this rule.
        !t.HasAttribute("NDepend.Attributes.IsNotDeadCodeAttribute".AllowNoMatch()) &&
        // Exclude static types that define only const fields
        // because they cannot be seen as used in IL code.
        !(t.IsStatic && t.NbMethods == 0 && !t.Fields.Where(f => !f.IsLiteral).Any()))
// Select types unused
let typesUnused =
   from t in JustMyCode.Types where
   t.NbTypesUsingMe == 0 && canTypeBeConsideredAsDeadProc(t)
   select t
// Dead types = types used only by unused types (recursive)
let deadTypesMetric = typesUnused.FillIterative(
types => from t in codeBase.Application.Types.UsedByAny(types).Except(types)
         where canTypeBeConsideredAsDeadProc(t) &&
               t.TypesUsingMe.Intersect(types).Count() == t.NbTypesUsingMe
         select t)
from t in deadTypesMetric.DefinitionDomain
]]></code>
    <description><![CDATA[Potentially dead Types]]></description>
  </rule>
  <rule>
    <key>PotentiallyDeadMethods</key>
    <severity>CRITICAL</severity>
    <name><![CDATA[Potentially dead Methods]]></name>
    <group>Dead Code</group>
    <scope>Method</scope>
    <code><![CDATA[
warnif count > 0
// Filter procedure for methods that should'nt be considered as dead
let canMethodBeConsideredAsDeadProc = new Func<IMethod, bool>(
    m => !m.IsPubliclyVisible &&       // Public methods might be used by client applications of your assemblies.
         !m.IsEntryPoint &&            // Main() method is not used by-design.
         !m.IsExplicitInterfaceImpl && // The IL code never explicitely calls explicit interface methods implementation.
         !m.IsClassConstructor &&      // The IL code never explicitely calls class constructors.
         !m.IsFinalizer &&             // The IL code never explicitely calls finalizers.
         !m.IsVirtual &&               // Only check for non virtual method that are not seen as used in IL.
         !(m.IsConstructor &&          // Don't take account of protected ctor that might be call by a derived ctors.
           m.IsProtected) &&
         !m.IsEventAdder &&            // The IL code never explicitely calls events adder/remover.
         !m.IsEventRemover &&
         !m.IsGeneratedByCompiler &&
         !m.ParentType.IsDelegate &&
         // Methods tagged with these two attributes are called by the serialization infrastructure.
         !m.HasAttribute("System.Runtime.Serialization.OnSerializingAttribute".AllowNoMatch()) &&
         !m.HasAttribute("System.Runtime.Serialization.OnDeserializedAttribute".AllowNoMatch()) &&
         // If you don't want to link NDepend.API.dll, you can use your own IsNotDeadCodeAttribute and adapt this rule.
         !m.HasAttribute("NDepend.Attributes.IsNotDeadCodeAttribute".AllowNoMatch()))
// Get methods unused
let methodsUnused =
   from m in JustMyCode.Methods where
   m.NbMethodsCallingMe == 0 &&
   canMethodBeConsideredAsDeadProc(m)
   select m
// Dead methods = methods used only by unused methods (recursive)
let deadMethodsMetric = methodsUnused.FillIterative(
   methods => // Unique loop, just to let a chance to build the hashset.
              from o in (new object()).ToEnumerable()
              // Use a hashet to make Intersect calls much faster!
              let hashset = methods.ToHashSet()
              from m in codeBase.Application.Methods.UsedByAny(methods).Except(methods)
              where canMethodBeConsideredAsDeadProc(m) &&
                    // Select methods called only by methods already considered as dead
                    hashset.Intersect(m.MethodsCallingMe).Count() == m.NbMethodsCallingMe
              select m)
from m in JustMyCode.Methods.Intersect(deadMethodsMetric.DefinitionDomain)
]]></code>
    <description><![CDATA[Potentially dead Methods]]></description>
  </rule>
  <rule>
    <key>WrongUsageOfIsnotdeadcodeattribute</key>
    <severity>MINOR</severity>
    <name><![CDATA[Wrong usage of IsNotDeadCodeAttribute]]></name>
    <group>Dead Code</group>
    <scope>Type</scope>
    <code><![CDATA[
// This IsNotDeadCodeAttribute can be used to signify that
// despite a member could be removed without provoking any syntax error
// (we also say it is dead code), your intention is to not remove this member.
// Default 'Dead Code' code rules take account of this attribute.
// IsNotDeadCodeAttribute is defined in NDepend.API.dll
// If you don't want to link NDepend.API.dll, you can use
// your own IsNotDeadCodeAttribute and adapt this rule.
warnif count == 1
let tAttr = Types.WithFullName("NDepend.Attributes.IsNotDeadCodeAttribute").FirstOrDefault()
where tAttr != null
// Get types that do a wrong usage of IsNotDeadCodeAttribute
let types = from t in Application.Types where
   t.HasAttribute("NDepend.Attributes.IsNotDeadCodeAttribute".AllowNoMatch()) &&
   ( // types used don't need to be tagged with IsNotDeadCodeAttribute!
     t.NbTypesUsingMe > 0  ||
     // Static types that define only const fields cannot be seen as used in IL code.
     // They don't need to be tagged with IsNotDeadCodeAttribute.
     (t.IsStatic && t.NbMethods == 0 && !t.Fields.Where(f => !f.IsLiteral).Any())
   )
   select t
// Get methods that do a wrong usage of IsNotDeadCodeAttribute
let methods = from m in Application.Methods where
   m.HasAttribute("NDepend.Attributes.IsNotDeadCodeAttribute".AllowNoMatch()) &&
   m.NbMethodsCallingMe > 0
   select m
// Get fields that do a wrong usage of IsNotDeadCodeAttribute
let fields = from f in Application.Fields where
   f.HasAttribute("NDepend.Attributes.IsNotDeadCodeAttribute".AllowNoMatch()) &&
   f.NbMethodsUsingMe > 0
   select f
where types.Count() > 0 || methods.Count() > 0 || fields.Count() > 0
]]></code>
    <description><![CDATA[Wrong usage of IsNotDeadCodeAttribute]]></description>
  </rule>
  <rule>
    <key>MethodsThatCouldHaveALowerVisibility</key>
    <severity>MINOR</severity>
    <name><![CDATA[Methods that could have a lower visibility]]></name>
    <group>Visibility</group>
    <scope>Method</scope>
    <code><![CDATA[
// This rule tells which methods can be declared with a lower visibility.
// (like 'private' is a visibility lower than 'internal' which is lower than 'public').
// Reducing visibility is a good practice because this fosters encapsulation
// and with it maintainability and extensibility.
warnif count > 0 from m in JustMyCode.Methods where
  m.Visibility != m.OptimalVisibility &&
  !m.HasAttribute("NDepend.Attributes.CannotDecreaseVisibilityAttribute".AllowNoMatch()) &&
  !m.HasAttribute("NDepend.Attributes.IsNotDeadCodeAttribute".AllowNoMatch()) &&
  // If you don't want to link NDepend.API.dll, you can use your own attributes and adapt this rule.
  // Eliminate default constructor from the result.
  // Whatever the visibility of the declaring class,
  // default constructors are public and introduce noise
  // in the current rule.
  !( m.IsConstructor && m.IsPublic && m.NbParameters == 0) &&
  // Don't decrease the visibility of Main() methods.
  !m.IsEntryPoint
]]></code>
    <description><![CDATA[Methods that could have a lower visibility]]></description>
  </rule>
  <rule>
    <key>TypesThatCouldHaveALowerVisibility</key>
    <severity>MINOR</severity>
    <name><![CDATA[Types that could have a lower visibility]]></name>
    <group>Visibility</group>
    <scope>Type</scope>
    <code><![CDATA[
// This rule tells which types can be declared with a lower visibility.
// (like 'private' is a visibility lower than 'internal' which is lower than 'public').
// Reducing visibility is a good practice because this fosters encapsulation
// and with it maintainability and extensibility.
warnif count > 0 from t in JustMyCode.Types where
  t.Visibility != t.OptimalVisibility &&
  // If you don't want to link NDepend.API.dll, you can use your own attributes and adapt this rule.
 !t.HasAttribute("NDepend.Attributes.CannotDecreaseVisibilityAttribute".AllowNoMatch()) &&
 !t.HasAttribute("NDepend.Attributes.IsNotDeadCodeAttribute".AllowNoMatch()) &&
  // Static types that define only const fields cannot be seen as used in IL code.
  // They don't have to be tagged with CannotDecreaseVisibilityAttribute.
  !( t.IsStatic &&
    !t.Methods.Any(m => !m.IsClassConstructor) &&
    !t.Fields.Any(f => !f.IsLiteral && !(f.IsStatic && f.IsInitOnly))) &&
  // A type used by an interface that has the same visibility
  // cannot have its visibility decreased, else a compilation error occurs!
  !t.TypesUsingMe.Any(tUser =>
        tUser.IsInterface &&
        tUser.Visibility == t.Visibility)
]]></code>
    <description><![CDATA[Types that could have a lower visibility]]></description>
  </rule>
  <rule>
    <key>TypesThatCouldBeDeclaredAsPrivateNestedInAParentType</key>
    <severity>MINOR</severity>
    <name><![CDATA[Types that could be declared as private, nested in a parent type]]></name>
    <group>Visibility</group>
    <scope>Type</scope>
    <code><![CDATA[
// The conditions for a type to be nested into a parent type
// is that the parent type is the only type using it,
// and that the parent type is declared in the same namespace.
//
// Declaring a type as private into a parent type helps enforcing encapsulation.
// But since nested private types are hardly testable, this rule might
// not be applied for types used directly by tests.
warnif count > 0
from t in Application.Types
where !t.IsGeneratedByCompiler &&
      !t.IsNested &&
      !t.IsPubliclyVisible &&
       // Only one type user...
       t.TypesUsingMe.Count() == 1
let couldBeNestedIn = t.TypesUsingMe.Single()
where !couldBeNestedIn.IsGeneratedByCompiler &&
       // ...declared in the same namespace
       couldBeNestedIn.ParentNamespace == t.ParentNamespace
]]></code>
    <description><![CDATA[Types that could be declared as private, nested in a parent type]]></description>
  </rule>
  <rule>
    <key>ConstructorsOfAbstractClassesShouldBeDeclaredAsProtectedOrPrivate</key>
    <severity>CRITICAL</severity>
    <name><![CDATA[Constructors of abstract classes should be declared as protected or private]]></name>
    <group>Visibility</group>
    <scope>Type</scope>
    <code><![CDATA[
// Constructors of an abstract class can be accessed only from its class and derived class.
// Declaring such a constructor with another visibility level is useless and potentially misleading.
// Notice that if a constructor of an abstract class is declared as private,
// it can only be accessed from derived classes nested in the abstract class.
warnif count > 0
from t in Application.Types where
  t.IsClass &&
  t.IsAbstract
let ctors = t.Constructors.Where(c => !c.IsProtected && !c.IsPrivate)
where ctors.Count() > 0
]]></code>
    <description><![CDATA[Constructors of abstract classes should be declared as protected or private]]></description>
  </rule>
  <rule>
    <key>AvoidPublicMethodsNotPubliclyVisible</key>
    <severity>MINOR</severity>
    <name><![CDATA[Avoid public methods not publicly visible]]></name>
    <group>Visibility</group>
    <scope>Method</scope>
    <code><![CDATA[
// Matched methods are declared public but are not publicly visible by assemblies consumers.
// Their visibility level must be decreased.
warnif count > 0
from m in JustMyCode.Methods where
   !m.IsPubliclyVisible && m.IsPublic &&
   // Eliminate virtual methods
   !m.IsVirtual &&
   // Eliminate interface and delegate types
   !m.ParentType.IsInterface &&
   !m.ParentType.IsDelegate &&
   // Eliminate default constructors
   !(m.IsConstructor && m.NbParameters == 0) &&
   // Eliminate operators that must be declared public
   !m.IsOperator &&
   // Eliminate methods generated by compiler
   !m.IsGeneratedByCompiler
]]></code>
    <description><![CDATA[Avoid public methods not publicly visible]]></description>
  </rule>
  <rule>
    <key>MethodsThatShouldBeDeclaredAspublicInCpublicInVbnet</key>
    <severity>MINOR</severity>
    <name><![CDATA[Methods that should be declared as 'public' in C#, 'Public' in VB.NET]]></name>
    <group>Visibility</group>
    <scope>Method</scope>
    <code><![CDATA[
// The condition 'ShouldBePublic' shows code elements
// declared as 'internal\Friend' that are used outside
// of their assembly thanks to the Attribute
// System.Runtime.CompilerServices.InternalsVisibleToAttribute
from m in Application.Methods where
  m.ShouldBePublic
let usedInAssemblies = m.MethodsCallingMe.ParentAssemblies().Except(m.ParentAssembly)
]]></code>
    <description><![CDATA[Methods that should be declared as 'public' in C#, 'Public' in VB.NET]]></description>
  </rule>
  <rule>
    <key>WrongUsageOfCannotdecreasevisibilityattribute</key>
    <severity>MINOR</severity>
    <name><![CDATA[Wrong usage of CannotDecreaseVisibilityAttribute]]></name>
    <group>Visibility</group>
    <scope>Type</scope>
    <code><![CDATA[
// The CannotDecreaseVisibilityAttribute can be used to signify that despite
// a member could have a lower visibility without provoking any syntax error,
// your intention is to not change this member visibility.
// Default Visibility code rules take account of this attribute.
// CannotDecreaseVisibilityAttribute is defined in NDepend.API.dll
// If you don't want to link NDepend.API.dll, you can use
// your own CannotDecreaseVisibilityAttribute and adapt this rule.
warnif count == 1
let tAttr = Types.WithFullName("NDepend.Attributes.CannotDecreaseVisibilityAttribute").FirstOrDefault()
where tAttr != null
// Get types that do a wrong usage of CannotDecreaseVisibilityAttribute
let types = from t in Application.Types where
   t.HasAttribute("NDepend.Attributes.CannotDecreaseVisibilityAttribute".AllowNoMatch()) &&
   ( t.Visibility == t.OptimalVisibility ||
     // Static types that define only const fields cannot be seen as used in IL code.
     // They don't need to be tagged with CannotDecreaseVisibilityAttribute.
     (t.IsStatic && t.NbMethods == 0 && !t.Fields.Where(f => !f.IsLiteral).Any())
   )
   select t
// Get methods that do a wrong usage of CannotDecreaseVisibilityAttribute
let methods = from m in Application.Methods where
   m.HasAttribute("NDepend.Attributes.CannotDecreaseVisibilityAttribute".AllowNoMatch()) &&
   m.Visibility == m.OptimalVisibility
   select m
// Get fields that do a wrong usage of CannotDecreaseVisibilityAttribute
let fields = from f in Application.Fields where
   f.HasAttribute("NDepend.Attributes.CannotDecreaseVisibilityAttribute".AllowNoMatch()) &&
   f.Visibility == f.OptimalVisibility
   select f
where types.Count() > 0 || methods.Count() > 0 || fields.Count() > 0
]]></code>
    <description><![CDATA[Wrong usage of CannotDecreaseVisibilityAttribute]]></description>
  </rule>
  <rule>
    <key>EventHandlerMethodsShouldBeDeclaredPrivate</key>
    <severity>MINOR</severity>
    <name><![CDATA[Event handler methods should be declared private]]></name>
    <group>Visibility</group>
    <scope>Method</scope>
    <code><![CDATA[
warnif count > 0
from m in Application.Methods where
  !m.IsPrivate &&
   // A method is considered as event handler if...
   m.NbParameters==2 &&            // ...it has two parameters..
   m.Name.Contains("Object") &&    // ...of types Object...
   m.Name.Contains("EventArgs") && // ...and EventArgs
   // Discard special cases
  !m.ParentType.IsDelegate &&
  !m.IsGeneratedByCompiler
]]></code>
    <description><![CDATA[Event handler methods should be declared private]]></description>
  </rule>
  <rule>
    <key>StructuresShouldBeImmutable</key>
    <severity>MINOR</severity>
    <name><![CDATA[Structures should be immutable]]></name>
    <group>Purity - Immutability - Side-Effects</group>
    <scope>Type</scope>
    <code><![CDATA[
warnif count > 0 from t in Application.Types where
   t.IsStructure &&
  !t.IsImmutable
let mutableFields = t.Fields.Where(f => !f.IsImmutable)
]]></code>
    <description><![CDATA[Structures should be immutable]]></description>
  </rule>
  <rule>
    <key>PropertyGettersShouldBeImmutable</key>
    <severity>MINOR</severity>
    <name><![CDATA[Property Getters should be immutable]]></name>
    <group>Purity - Immutability - Side-Effects</group>
    <scope>Method</scope>
    <code><![CDATA[
warnif count > 0 from m in Application.Methods where
  m.IsPropertyGetter &&
  ( ( !m.IsStatic && m.ChangesObjectState) ||
    (  m.IsStatic && m.ChangesTypeState) )
let fieldsAssigned = m.FieldsAssigned
]]></code>
    <description><![CDATA[Property Getters should be immutable]]></description>
  </rule>
  <rule>
    <key>TypesImmutableShouldBeTaggedWithImmutableattribute</key>
    <severity>MINOR</severity>
    <name><![CDATA[Types immutable should be tagged with ImmutableAttribute]]></name>
    <group>Purity - Immutability - Side-Effects</group>
    <scope>Type</scope>
    <code><![CDATA[
from t in Application.Types where
  !t.HasAttribute ("NDepend.Attributes.ImmutableAttribute".AllowNoMatch()) &&
  t.IsImmutable
]]></code>
    <description><![CDATA[Types immutable should be tagged with ImmutableAttribute]]></description>
  </rule>
  <rule>
    <key>MethodsTaggedWithPureattributeMustBePure</key>
    <severity>MINOR</severity>
    <name><![CDATA[Methods tagged with PureAttribute must be pure]]></name>
    <group>Purity - Immutability - Side-Effects</group>
    <scope>Method</scope>
    <code><![CDATA[
warnif count > 0 from m in Application.Methods where
  ( m.HasAttribute ("NDepend.Attributes.PureAttribute".AllowNoMatch()) ||
    m.HasAttribute ("System.Diagnostics.Contract.PureAttribute".AllowNoMatch()) ) &&
  ( m.ChangesObjectState || m.ChangesTypeState ) &&
    m.NbLinesOfCode > 0
let fieldsAssigned = m.FieldsAssigned
]]></code>
    <description><![CDATA[Methods tagged with PureAttribute must be pure]]></description>
  </rule>
  <rule>
    <key>PureMethodsShouldBeTaggedWithPureattribute</key>
    <severity>MINOR</severity>
    <name><![CDATA[Pure methods should be tagged with PureAttribute]]></name>
    <group>Purity - Immutability - Side-Effects</group>
    <scope>Method</scope>
    <code><![CDATA[
from m in Application.Methods where
  !m.HasAttribute ("NDepend.Attributes.PureAttribute".AllowNoMatch()) &&
  !m.HasAttribute ("System.Diagnostics.Contract.PureAttribute".AllowNoMatch()) &&
  !m.ChangesObjectState && !m.ChangesTypeState &&
   m.NbLinesOfCode > 0
]]></code>
    <description><![CDATA[Pure methods should be tagged with PureAttribute]]></description>
  </rule>
  <rule>
    <key>InterfaceNameShouldBeginWithAi</key>
    <severity>CRITICAL</severity>
    <name><![CDATA[Interface name should begin with a 'I']]></name>
    <group>Naming Conventions</group>
    <scope>Type</scope>
    <code><![CDATA[
warnif count > 0 from t in Application.Types where
t.IsInterface
// Discard outter type(s) name prefix for nested types
let name = !t.IsNested  ? t.Name : t.Name.Substring(t.Name.LastIndexOf('+') + 1, t.Name.Length - t.Name.LastIndexOf('+') - 1)
where name[0] != 'I'
]]></code>
    <description><![CDATA[Interface name should begin with a 'I']]></description>
  </rule>
  <rule>
    <key>AbstractBaseClassShouldBeSuffixedWithbase</key>
    <severity>MINOR</severity>
    <name><![CDATA[Abstract base class should be suffixed with 'Base']]></name>
    <group>Naming Conventions</group>
    <scope>Type</scope>
    <code><![CDATA[
warnif count > 0 from t in Application.Types where
  t.IsAbstract &&
  t.IsClass &&
  // equivalent to:   DepthOfDeriveFrom "System.Object" == 1
  t.DepthOfInheritance == 1 &&
  ((!t.IsGeneric && !t.NameLike (@"Base$")) ||
   ( t.IsGeneric && !t.NameLike (@"Base<")))
]]></code>
    <description><![CDATA[Abstract base class should be suffixed with 'Base']]></description>
  </rule>
  <rule>
    <key>ExceptionClassNameShouldBeSuffixedWithexception</key>
    <severity>CRITICAL</severity>
    <name><![CDATA[Exception class name should be suffixed with 'Exception']]></name>
    <group>Naming Conventions</group>
    <scope>Type</scope>
    <code><![CDATA[
warnif count > 0 from t in Application.Types where
  t.IsExceptionClass &&
  // We use SimpleName, because in case of generic Exception type
  // SimpleName suppresses the generic suffix (like <T>).
  !t.SimpleNameLike (@"Exception$") &&
  !t.SimpleNameLike (@"ExceptionBase$") // Allow the second suffix Base
                                        // for base exception classes.
]]></code>
    <description><![CDATA[Exception class name should be suffixed with 'Exception']]></description>
  </rule>
  <rule>
    <key>AttributeClassNameShouldBeSuffixedWithattribute</key>
    <severity>CRITICAL</severity>
    <name><![CDATA[Attribute class name should be suffixed with 'Attribute']]></name>
    <group>Naming Conventions</group>
    <scope>Type</scope>
    <code><![CDATA[
warnif count > 0 from t in Application.Types where
   t.IsAttributeClass &&
  !t.NameLike (@"Attribute$")
]]></code>
    <description><![CDATA[Attribute class name should be suffixed with 'Attribute']]></description>
  </rule>
  <rule>
    <key>TypesNameShouldBeginWithAnUpperCharacter</key>
    <severity>MINOR</severity>
    <name><![CDATA[Types name should begin with an Upper character]]></name>
    <group>Naming Conventions</group>
    <scope>Type</scope>
    <code><![CDATA[
warnif count > 0 from t in JustMyCode.Types where
  // The name of a type should begin with an Upper letter.
  !t.SimpleNameLike (@"^[A-Z]") &&
  // Except if it is generated by compiler or ...
  !t.IsSpecialName &&
  !t.IsGeneratedByCompiler
]]></code>
    <description><![CDATA[Types name should begin with an Upper character]]></description>
  </rule>
  <rule>
    <key>MethodsNameShouldBeginWithAnUpperCharacter</key>
    <severity>MINOR</severity>
    <name><![CDATA[Methods name should begin with an Upper character]]></name>
    <group>Naming Conventions</group>
    <scope>Method</scope>
    <code><![CDATA[
warnif count > 0 from m in JustMyCode.Methods where
  !m.NameLike (@"^[A-Z]") &&
  !m.IsSpecialName &&
  !m.IsGeneratedByCompiler
]]></code>
    <description><![CDATA[Methods name should begin with an Upper character]]></description>
  </rule>
  <rule>
    <key>AvoidTypesWithNameTooLong</key>
    <severity>MINOR</severity>
    <name><![CDATA[Avoid types with name too long]]></name>
    <group>Naming Conventions</group>
    <scope>Type</scope>
    <code><![CDATA[
warnif count > 0 from t in Application.Types
where !t.IsGeneratedByCompiler
where t.SimpleName.Length > 35
]]></code>
    <description><![CDATA[Avoid types with name too long]]></description>
  </rule>
  <rule>
    <key>AvoidMethodsWithNameTooLong</key>
    <severity>MINOR</severity>
    <name><![CDATA[Avoid methods with name too long]]></name>
    <group>Naming Conventions</group>
    <scope>Method</scope>
    <code><![CDATA[
warnif count > 0 from m in Application.Methods where
 !m.IsExplicitInterfaceImpl &&
 !m.IsGeneratedByCompiler &&
 ((!m.IsSpecialName && m.SimpleName.Length > 35) ||
   // Property getter/setter are prefixed with "get_" "set_" of length 4.
  ( m.IsSpecialName && m.SimpleName.Length - 4 > 35))
]]></code>
    <description><![CDATA[Avoid methods with name too long]]></description>
  </rule>
  <rule>
    <key>AvoidNamingTypesAndNamespacesWithTheSameIdentifier</key>
    <severity>MINOR</severity>
    <name><![CDATA[Avoid naming types and namespaces with the same identifier]]></name>
    <group>Naming Conventions</group>
    <scope>Type</scope>
    <code><![CDATA[
// Not only this can provoke compiler resolution collision,
// but also, this makes code less maintainable because
// concepts are not concisely identified.
warnif count > 0
let hashsetShortNames = Namespaces.Where(n => n.Name.Length > 0).Select(n => n.SimpleName).ToHashSet()
from t in JustMyCode.Types
where hashsetShortNames.Contains(t.Name)
]]></code>
    <description><![CDATA[Avoid naming types and namespaces with the same identifier]]></description>
  </rule>
  <rule>
    <key>DontCallYourMethodDispose</key>
    <severity>CRITICAL</severity>
    <name><![CDATA[Don't call your method Dispose]]></name>
    <group>Naming Conventions</group>
    <scope>Method</scope>
    <code><![CDATA[
// Methods shouldn't be called Dispose,
// this syntax is reserved for System.IDisposable type usage.
from m in Application.Methods.WithSimpleName("Dispose")
where !m.ParentType.Implement("System.IDisposable".AllowNoMatch())
]]></code>
    <description><![CDATA[Don't call your method Dispose]]></description>
  </rule>
  <rule>
    <key>MethodsPrefixedWithtryShouldReturnABoolean</key>
    <severity>MINOR</severity>
    <name><![CDATA[Methods prefixed with 'Try' should return a boolean]]></name>
    <group>Naming Conventions</group>
    <scope>Method</scope>
    <code><![CDATA[
// and such TryXXX method can eventually have out parameters to return results.
// Get inspired from the API design of:
// System.Int32.TryParse(int,out string):bool
warnif count > 0
from m in Application.Methods where
  m.SimpleNameLike("^Try") &&
  m.ReturnType != null &&
  m.ReturnType.FullName != "System.Boolean"
]]></code>
    <description><![CDATA[Methods prefixed with 'Try' should return a boolean]]></description>
  </rule>
  <rule>
    <key>MarkIserializableTypesWithSerializableattribute</key>
    <severity>MINOR</severity>
    <name><![CDATA[Mark ISerializable types with SerializableAttribute]]></name>
    <group>System</group>
    <scope>Type</scope>
    <code><![CDATA[
from t in Application.Types where
  t.IsPublic &&
 !t.IsDelegate &&
  t.Implement ("System.Runtime.Serialization.ISerializable".AllowNoMatch()) &&
 !t.HasAttribute ("System.SerializableAttribute".AllowNoMatch())
]]></code>
    <description><![CDATA[Mark ISerializable types with SerializableAttribute]]></description>
  </rule>
  <rule>
    <key>MarkAttributesWithAttributeusageattribute</key>
    <severity>MINOR</severity>
    <name><![CDATA[Mark attributes with AttributeUsageAttribute]]></name>
    <group>System</group>
    <scope>Type</scope>
    <code><![CDATA[
warnif count > 0 from t in Application.Types where
   t.DeriveFrom ("System.Attribute".AllowNoMatch()) &&
  !t.HasAttribute ("System.AttributeUsageAttribute".AllowNoMatch())
]]></code>
    <description><![CDATA[Mark attributes with AttributeUsageAttribute]]></description>
  </rule>
  <rule>
    <key>RemoveCallsToGccollect</key>
    <severity>MINOR</severity>
    <name><![CDATA[Remove calls to GC.Collect()]]></name>
    <group>System</group>
    <scope>Method</scope>
    <code><![CDATA[
warnif count > 0
let gcCollectMethods = ThirdParty.Methods.WithFullNameIn(
   "System.GC.Collect()",
   "System.GC.Collect(Int32)",
   "System.GC.Collect(Int32,GCCollectionMode)")
from m in Application.Methods.UsingAny(gcCollectMethods)
]]></code>
    <description><![CDATA[Remove calls to GC.Collect()]]></description>
  </rule>
  <rule>
    <key>DontCallGccollectWithoutCallingGcwaitforpendingfinalizers</key>
    <severity>MINOR</severity>
    <name><![CDATA[Don't call GC.Collect() without calling GC.WaitForPendingFinalizers()]]></name>
    <group>System</group>
    <scope>Method</scope>
    <code><![CDATA[
warnif count > 0
let gcCollectMethods = ThirdParty.Methods.WithFullNameIn(
   "System.GC.Collect()",
   "System.GC.Collect(Int32)",
   "System.GC.Collect(Int32,GCCollectionMode)")
from m in Application.Methods.UsingAny(gcCollectMethods) where
  !m.IsUsing ("System.GC.WaitForPendingFinalizers()".AllowNoMatch())
]]></code>
    <description><![CDATA[Don't call GC.Collect() without calling GC.WaitForPendingFinalizers()]]></description>
  </rule>
  <rule>
    <key>DoNotRaiseTooGeneralExceptionTypes</key>
    <severity>MINOR</severity>
    <name><![CDATA[Do not raise too general exception types]]></name>
    <group>System</group>
    <scope>Method</scope>
    <code><![CDATA[
warnif count > 0 from m in Application.Methods where
  // Test for non-constructor, else this rule
  // would warn on ctor of classes that derive
  // from these exception types.
 !m.IsConstructor && (
    m.CreateA("System.Exception".AllowNoMatch()) ||
    m.CreateA("System.ApplicationException".AllowNoMatch()) ||
    m.CreateA("System.SystemException".AllowNoMatch()) )
]]></code>
    <description><![CDATA[Do not raise too general exception types]]></description>
  </rule>
  <rule>
    <key>DoNotRaiseReservedExceptionTypes</key>
    <severity>MINOR</severity>
    <name><![CDATA[Do not raise reserved exception types]]></name>
    <group>System</group>
    <scope>Method</scope>
    <code><![CDATA[
warnif count > 0
let reservedExceptions = ThirdParty.Types.WithFullNameIn(
   "System.ExecutionEngineException",
   "System.IndexOutOfRangeException",
   "System.NullReferenceException",
   "System.OutOfMemoryException",
   "System.StackOverflowException",
   "System.InvalidProgramException",
   "System.AccessViolationException",
   "System.CannotUnloadAppDomainException",
   "System.BadImageFormatException",
   "System.DataMisalignedException")
from m in Application.Methods.ThatCreateAny(reservedExceptions)
let reservedExceptionsCreated = reservedExceptions.Where(t => m.IsUsing(t))
]]></code>
    <description><![CDATA[Do not raise reserved exception types]]></description>
  </rule>
  <rule>
    <key>UseIntegralOrStringArgumentForIndexers</key>
    <severity>MINOR</severity>
    <name><![CDATA[Use integral or string argument for indexers]]></name>
    <group>System</group>
    <scope>Method</scope>
    <code><![CDATA[
from m in Application.Methods where
m.IsIndexerGetter &&
 !( (m.Name == @"get_Item(String)") ||
     m.NameLike (@"get_Item\(Int") ||
     m.NameLike (@"get_Item\(Byte") ||
     m.NameLike (@"get_Item\(SByte") )
]]></code>
    <description><![CDATA[Use integral or string argument for indexers]]></description>
  </rule>
  <rule>
    <key>TypesShouldNotExtendSystemapplicationexception</key>
    <severity>MINOR</severity>
    <name><![CDATA[Types should not extend System.ApplicationException]]></name>
    <group>System</group>
    <scope>Type</scope>
    <code><![CDATA[
warnif count > 0 from t in Application.Types where
  t.DeriveFrom("System.ApplicationException".AllowNoMatch())
]]></code>
    <description><![CDATA[Types should not extend System.ApplicationException]]></description>
  </rule>
  <rule>
    <key>DontUsenetxHashtableAndArraylist</key>
    <severity>MINOR</severity>
    <name><![CDATA[Don't use .NET 1.x HashTable and ArrayList]]></name>
    <group>System.Collection</group>
    <scope>Method</scope>
    <code><![CDATA[
warnif count > 0
let forbiddenTypes = ThirdParty.Types.WithFullNameIn("System.Collections.HashTable", "System.Collections.ArrayList")
where forbiddenTypes.Count() > 0
from m in Application.Methods.ThatCreateAny(forbiddenTypes)
]]></code>
    <description><![CDATA[Don't use .NET 1.x HashTable and ArrayList]]></description>
  </rule>
  <rule>
    <key>PinvokesShouldBeStaticAndNotBeVisible</key>
    <severity>MINOR</severity>
    <name><![CDATA[P/Invokes should be static and not be visible]]></name>
    <group>System.Runtime.InteropServices</group>
    <scope>Method</scope>
    <code><![CDATA[
warnif count > 0 from m in Application.Methods where
  !m.IsThirdParty &&
  (m.HasAttribute ("System.Runtime.InteropServices.DllImportAttribute".AllowNoMatch())) &&
  ( m.IsPublic ||
   !m.IsStatic)
]]></code>
    <description><![CDATA[P/Invokes should be static and not be visible]]></description>
  </rule>
  <rule>
    <key>MovePinvokesToNativemethodsClass</key>
    <severity>MINOR</severity>
    <name><![CDATA[Move P/Invokes to NativeMethods class]]></name>
    <group>System.Runtime.InteropServices</group>
    <scope>Method</scope>
    <code><![CDATA[
warnif count > 0 from m in Application.Methods where
   m.HasAttribute ("System.Runtime.InteropServices.DllImportAttribute".AllowNoMatch()) &&
   m.ParentType.Name != "NativeMethods"
]]></code>
    <description><![CDATA[Move P/Invokes to NativeMethods class]]></description>
  </rule>
  <rule>
    <key>NativemethodsClassShouldBeStaticAndInternal</key>
    <severity>MINOR</severity>
    <name><![CDATA[NativeMethods class should be static and internal]]></name>
    <group>System.Runtime.InteropServices</group>
    <scope>Type</scope>
    <code><![CDATA[
warnif count > 0 from t in Application.Types.WithNameIn(
   @"NativeMethods", "SafeNativeMethods", "UnsafeNativeMethods") where
  t.IsPublic || !t.IsStatic
]]></code>
    <description><![CDATA[NativeMethods class should be static and internal]]></description>
  </rule>
  <rule>
    <key>MethodNonsynchronizedThatReadMutableStates</key>
    <severity>MINOR</severity>
    <name><![CDATA[Method non-synchronized that read mutable states]]></name>
    <group>System.Threading</group>
    <scope>Method</scope>
    <code><![CDATA[
from m in Application.Methods where
 (m.ReadsMutableObjectState || m.ReadsMutableTypeState) &&
 !m.IsUsing ("System.Threading.Monitor".AllowNoMatch()) &&
 !m.IsUsing ("System.Threading.ReaderWriterLock".AllowNoMatch())
]]></code>
    <description><![CDATA[Method non-synchronized that read mutable states]]></description>
  </rule>
  <rule>
    <key>DontCreateThreadsExplicitely</key>
    <severity>MINOR</severity>
    <name><![CDATA[Don't create threads explicitely]]></name>
    <group>System.Threading</group>
    <scope>Method</scope>
    <code><![CDATA[
warnif count > 0 from m in Application.Methods where
  m.CreateA ("System.Threading.Thread".AllowNoMatch())
]]></code>
    <description><![CDATA[Don't create threads explicitely]]></description>
  </rule>
  <rule>
    <key>DontUseDangerousThreadingMethods</key>
    <severity>MINOR</severity>
    <name><![CDATA[Don't use dangerous threading methods]]></name>
    <group>System.Threading</group>
    <scope>Method</scope>
    <code><![CDATA[
warnif count > 0
let wrongMethods = ThirdParty.Methods.WithFullNameIn(
  // Usage of Thread.Abort() is dangerous.
  // More information on this here:
  // http://www.interact-sw.co.uk/iangblog/2004/11/12/cancellation
  "System.Threading.Thread.Abort()",
  "System.Threading.Thread.Abort(Object)",
  // Usage of Thread.Sleep() is a sign of
  // flawed design. More information on this here:
  // http://msmvps.com/blogs/peterritchie/archive/2007/04/26/thread-sleep-is-a-sign-of-a-poorly-designed-program.aspx
  "System.Threading.Thread.Sleep(Int32)",
  // Suspend() and Resume() are dangerous threading methods, marked as obsolete.
  // More information on workaround here:
  // http://stackoverflow.com/questions/382173/what-are-alternative-ways-to-suspend-and-resume-a-thread
  "System.Threading.Thread.Suspend()",
  "System.Threading.Thread.Resume()"
)
from m in Application.Methods.UsingAny(wrongMethods)
]]></code>
    <description><![CDATA[Don't use dangerous threading methods]]></description>
  </rule>
  <rule>
    <key>MonitorTryenterexitMustBeBothCalledWithinTheSameMethod</key>
    <severity>CRITICAL</severity>
    <name><![CDATA[Monitor TryEnter/Exit must be both called within the same method]]></name>
    <group>System.Threading</group>
    <scope>Method</scope>
    <code><![CDATA[
// Else you expose yourself to complex error-prone scenarios.
warnif count > 0
let enterMethods = ThirdParty.Methods.WithFullNameWildcardMatchIn(
   "System.Threading.Monitor.Enter(*",
   "System.Threading.Monitor.TryEnter(*")
from m in Application.Methods.UsingAny(enterMethods) where
 !m.IsUsing ("System.Threading.Monitor.Exit(Object)".AllowNoMatch())
]]></code>
    <description><![CDATA[Monitor TryEnter/Exit must be both called within the same method]]></description>
  </rule>
  <rule>
    <key>ReaderwriterlockAcquirereaderwriterlockreleaselockMustBeBothCalledWithinTheSameMethod</key>
    <severity>CRITICAL</severity>
    <name><![CDATA[ReaderWriterLock Acquire[Reader/Writer]Lock/ReleaseLock must be both called within the same method]]></name>
    <group>System.Threading</group>
    <scope>Method</scope>
    <code><![CDATA[
// Else you expose yourself to complex error-prone scenarios.
warnif count > 0
let acquireLockMethods = ThirdParty.Methods.WithFullNameWildcardMatch(
    "System.Threading.ReaderWriterLock.AcquireReaderLock(*")
from m in Application.Methods.UsingAny(acquireLockMethods) where
 !m.IsUsing ("System.Threading.ReaderWriterLock.ReleaseReaderLock()".AllowNoMatch()) &&
 !m.IsUsing ("System.Threading.ReaderWriterLock.ReleaseLock()".AllowNoMatch())
]]></code>
    <description><![CDATA[ReaderWriterLock Acquire[Reader/Writer]Lock/ReleaseLock must be both called within the same method]]></description>
  </rule>
  <rule>
    <key>MethodShouldNotReturnConcreteXmlnode</key>
    <severity>MINOR</severity>
    <name><![CDATA[Method should not return concrete XmlNode]]></name>
    <group>System.Xml</group>
    <scope>Method</scope>
    <code><![CDATA[
warnif count > 0
let concreteXmlTypes = ThirdParty.Types.WithFullNameIn(
       "System.Xml.XmlDocument",
       "System.Xml.XmlAttribute",
       "System.Xml.XmlDocumentFragment",
       "System.Xml.XmlEntity",
       "System.Xml.XmlLinkedNode",
       "System.Xml.XmlNotation",
       "System.Xml.XmlNode")
from m in Application.Methods.WithReturnTypeIn(concreteXmlTypes)
]]></code>
    <description><![CDATA[Method should not return concrete XmlNode]]></description>
  </rule>
  <rule>
    <key>TypesShouldNotExtendSystemxmlxmldocument</key>
    <severity>MINOR</severity>
    <name><![CDATA[Types should not extend System.Xml.XmlDocument]]></name>
    <group>System.Xml</group>
    <scope>Type</scope>
    <code><![CDATA[
warnif count > 0 from t in Application.Types where
  t.DeriveFrom("System.Xml.XmlDocument".AllowNoMatch())
]]></code>
    <description><![CDATA[Types should not extend System.Xml.XmlDocument]]></description>
  </rule>
  <rule>
    <key>DiscardGeneratedTypesFromJustmycode</key>
    <severity>MINOR</severity>
    <name><![CDATA[Discard generated Types from JustMyCode]]></name>
    <group>Defining JustMyCode</group>
    <scope>Type</scope>
    <code><![CDATA[
// --- Make sure to make this query richer to discard generated types from NDepend rules results ---
notmycode
from t in Application.Types where
  // Resources, Settings, or typed DataSet generated types for example, are tagged with this attribute
  t.HasAttribute ("System.CodeDom.Compiler.GeneratedCodeAttribute".AllowNoMatch()) ||
  // This attributes identifies a type or member that is not part of the user code for an application.
  t.HasAttribute ("System.Diagnostics.DebuggerNonUserCodeAttribute".AllowNoMatch()) ||
  // Delegate types are always generated
  t.IsDelegate ||
  // Discard ASP.NET page types generated by aspnet_compiler.exe
  // See: http://www.ndepend.com/FAQ.aspx#ASPNET
  t.ParentNamespace.Name.EqualsAny("ASP", "__ASP") ||
  // Discard generated type ContractException
  t.Name == "__ContractsRuntime+ContractException" ||
  t.FullName == "System.Diagnostics.Contracts.RuntimeContractsAttribute" ||
  t.FullName == "System.Diagnostics.Contracts.__ContractsRuntime" ||
  // Discard all types declared in a folder path containing the word "generated"
  (t.SourceFileDeclAvailable &&
   t.SourceDecls.All(s => s.SourceFile.FilePath.ParentDirectoryPath.ToString().ToLower().Contains("generated")))
]]></code>
    <description><![CDATA[Discard generated Types from JustMyCode]]></description>
  </rule>
  <rule>
    <key>MostUsedTypesrank</key>
    <severity>MINOR</severity>
    <name><![CDATA[Most used types (Rank)]]></name>
    <group>Statistics</group>
    <scope>Type</scope>
    <code><![CDATA[
(from t in Application.Types orderby t.Rank descending
 ]]></code>
    <description><![CDATA[Most used types (Rank)]]></description>
  </rule>
  <rule>
    <key>MostUsedMethodsrank</key>
    <severity>MINOR</severity>
    <name><![CDATA[Most used methods (Rank)]]></name>
    <group>Statistics</group>
    <scope>Method</scope>
    <code><![CDATA[
(from m in Application.Methods orderby m.Rank descending
 ]]></code>
    <description><![CDATA[Most used methods (Rank)]]></description>
  </rule>
  <rule>
    <key>MostUsedTypestypesusingme</key>
    <severity>MINOR</severity>
    <name><![CDATA[Most used types (#TypesUsingMe )]]></name>
    <group>Statistics</group>
    <scope>Type</scope>
    <code><![CDATA[
(from t in Types orderby t.NbTypesUsingMe descending
 ]]></code>
    <description><![CDATA[Most used types (#TypesUsingMe )]]></description>
  </rule>
  <rule>
    <key>MostUsedMethodsmethodscallingme</key>
    <severity>MINOR</severity>
    <name><![CDATA[Most used methods (#MethodsCallingMe )]]></name>
    <group>Statistics</group>
    <scope>Method</scope>
    <code><![CDATA[
(from m in Methods orderby m.NbMethodsCallingMe descending
 ]]></code>
    <description><![CDATA[Most used methods (#MethodsCallingMe )]]></description>
  </rule>
  <rule>
    <key>TypesThatUseManyOtherTypestypesused</key>
    <severity>MINOR</severity>
    <name><![CDATA[Types that use many other types (#TypesUsed )]]></name>
    <group>Statistics</group>
    <scope>Type</scope>
    <code><![CDATA[
(from t in Application.Types orderby t.NbTypesUsed descending
 ]]></code>
    <description><![CDATA[Types that use many other types (#TypesUsed )]]></description>
  </rule>
  <rule>
    <key>MethodsThatUseManyOtherMethodsmethodscalled</key>
    <severity>MINOR</severity>
    <name><![CDATA[Methods that use many other methods (#MethodsCalled )]]></name>
    <group>Statistics</group>
    <scope>Method</scope>
    <code><![CDATA[
(from m in Application.Methods orderby m.NbMethodsCalled descending
 ]]></code>
    <description><![CDATA[Methods that use many other methods (#MethodsCalled )]]></description>
  </rule>
  <rule>
    <key>HighlevelToLowlevelTypeslevel</key>
    <severity>MINOR</severity>
    <name><![CDATA[High-level to low-level types (Level)]]></name>
    <group>Statistics</group>
    <scope>Type</scope>
    <code><![CDATA[
from t in Application.Types orderby t.Level descending
]]></code>
    <description><![CDATA[High-level to low-level types (Level)]]></description>
  </rule>
  <rule>
    <key>HighlevelToLowlevelMethodslevel</key>
    <severity>MINOR</severity>
    <name><![CDATA[High-level to low-level methods (Level)]]></name>
    <group>Statistics</group>
    <scope>Method</scope>
    <code><![CDATA[
from m in Application.Methods orderby m.Level descending
]]></code>
    <description><![CDATA[High-level to low-level methods (Level)]]></description>
  </rule>
</rules>